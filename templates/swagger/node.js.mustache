'use strict';
var lib = require('./lib.js');

/*
DISABLES Console.log  for production
*/
console.log = function() {};



module.exports = function (RED) {
    function {{&className}}Node(config) {
        RED.nodes.createNode(this, config);
        {{#hasServiceParams}}
        this.service = RED.nodes.getNode(config.service);
        console.log('node.js.mustache this.service.host ', this.service.host);
        console.log('node.js.mustache config.host ', config.host);
        {{/hasServiceParams}}
        this.method = config.method;
        this.storedParams = config.storedParams;
          
        var node = this;
        console.log('first run: node = this', node);

        node.on('input', function (msg) {
            var node = this;
            var errorFlag = false;
            //console.log("this.service.host", this.service.host);
            //console.log("node.js.mustache config", config);
            //console.log("node.js.mustache this", this);
            var client;
            if (this.service && this.service.host) {
                if(msg.service){
                    if (msg.service.host) {
                        // override apiUrl with input msg
                        client = new lib.MerakiDashboardApi({ domain: msg.service.host });
                }              
                }else{
                    client = new lib.{{&className}}({ domain: this.service.host });
                }
            } else {
                node.error('Host in configuration node is not specified.', msg);
                errorFlag = true;
            }
            {{#isSecure}}
            {{#isSecureToken}}
            if (!errorFlag && this.service && this.service.credentials && this.service.credentials.secureTokenValue) {
                
                    if (this.service.secureTokenIsQuery) {
                        client.setToken(this.service.credentials.secureTokenValue,
                                        this.service.secureTokenHeaderOrQueryName, true);
                    } else {
                        client.setToken(this.service.credentials.secureTokenValue,
                                        this.service.secureTokenHeaderOrQueryName, false);
                    }
                
            }
            {{/isSecureToken}}
            {{#isSecureApiKey}}
            if (!errorFlag && this.service && this.service.credentials && this.service.credentials.secureApiKeyValue) {
                if(msg.service){
                    if (msg.service.apiKey) {
                        // override apiKey with input msg
                        client.setApiKey(msg.service.apiKey,
                            this.service.secureApiKeyHeaderOrQueryName, false);
                    }              
                }else{
                    if (this.service.secureApiKeyIsQuery) {
                        client.setApiKey(this.service.credentials.secureApiKeyValue,
                                        this.service.secureApiKeyHeaderOrQueryName, true);
                    } else {
                        client.setApiKey(this.service.credentials.secureApiKeyValue,
                                        this.service.secureApiKeyHeaderOrQueryName, false);
                    }
                }
            }
            {{/isSecureApiKey}}
            {{#isSecureBasic}}
            if (!errorFlag && this.service && this.service.credentials) {
                client.setBasicAuth(this.service.credentials.username, this.service.credentials.password);
            }
            {{/isSecureBasic}}
            {{/isSecure}}
            if (!errorFlag) {
                client.body = msg.payload;
            }

            var result;
            if(!node.storedParams){
                node.storedParams = [];
            }
            console.log('node.js node', node);
            var storedParamValsMap = {};
            node.storedParams.forEach(p =>{
                storedParamValsMap[p.camelCaseName] = p.value;
            })
            var storedParamTypeMap = {};
            node.storedParams.forEach(p =>{
                storedParamTypeMap[p.camelCaseName] = p.type;
            })

            node.method = node.method || RED.util.getMessageProperty(msg, "operationId");

            {{#methods}}
            if (!errorFlag && node.method === '{{&methodName}}') {
                var {{&methodName}}_parameters = [];
                var {{&methodName}}_nodeParam;
                var {{&methodName}}_nodeParamType;
                console.log('check if body param   msg.payload, ', msg.payload);
                {{#parameters}}              
                
                {{&methodName}}_nodeParam = storedParamValsMap['{{&camelCaseName}}'] ||
                    RED.util.getMessageProperty(msg, "{{&camelCaseName}}");

                {{&methodName}}_nodeParamType = storedParamTypeMap['{{&camelCaseName}}'] ||
                    RED.util.getMessageProperty(msg, "{{&camelCaseName}}");

                // Check if its the body param
                {{#isBodyParam}}
                // isBodyParam
                if (typeof msg.payload === 'object') {
                    {{&methodName}}_parameters.{{&camelCaseName}} = msg.payload;
                } else {
                    node.error('Unsupported type: \'' + (typeof msg.payload) + '\', ' + 'msg.payload must be JSON object or buffer.', msg);
                    errorFlag = true;
                }
                {{/isBodyParam}}
                {{#isNotBodyParam}}
                // notBodyParam                                            
                if ({{&methodName}}_nodeParamType === 'str') {
                    console.log('{{&methodName}}_nodeParamType is "str"');
                    {{&methodName}}_parameters.{{&camelCaseName}} = {{&methodName}}_nodeParam || undefined;
                } else {
                    console.log('{{&methodName}}_nodeParamType is not "str"')
                    {{&methodName}}_parameters.{{&camelCaseName}} = RED.util.getMessageProperty(msg, "{{&camelCaseName}}");
                }
                {{/isNotBodyParam}}
                {{/parameters}}
                result = client.{{&methodName}}({{&methodName}}_parameters);
                console.log('result', result);
            }
            {{/methods}}
            if (!errorFlag && result === undefined) {
                node.error('Method is not specified.', msg);
                errorFlag = true;
            }
            var setData = function (msg, data) {
                console.log('setData msg', msg)                  
                if (data) {
                    if (data.response) {
                        if (data.response.statusCode) {
                            msg.statusCode = data.response.statusCode;
                        }
                        if (data.response.headers) {
                            msg.headers = data.response.headers;
                        }
                        if (data.response.request && data.response.request.uri && data.response.request.uri.href) {
                            msg.responseUrl = data.response.request.uri.href;
                        }
                    }
                    if (data.body) {
                        msg.payload = data.body;
                        console.log('setData data.body', data.body)  
                    }
                }
                return msg;
            };
            if (!errorFlag) {
                node.status({ fill: 'blue', shape: 'dot', text: '{{&className}}.status.requesting' });
                result.then(function (data) {
                    node.send(setData(msg, data));
                    node.status({});
                }).catch(function (error) {
                    var message = null;
                    if (error && error.body && error.body.message) {
                        message = error.body.message;
                    }else{
                        message = error;
                    }
                    console.log('setData msg', msg);
                    node.error(message, setData(msg, error));
                    node.status({ fill: 'red', shape: 'ring', text: 'node-red:common.status.error' });
                });
            }
        });
    }

    RED.nodes.registerType('{{&nodeName}}', {{&className}}Node);
    {{#hasServiceParams}}
    function {{&className}}ServiceNode(n) {
        RED.nodes.createNode(this, n);
        
        this.host = n.host;
       

        {{#isSecure}}
        {{#isSecureToken}}
        this.secureTokenValue = n.secureTokenValue;
        this.secureTokenHeaderOrQueryName = n.secureTokenHeaderOrQueryName;
        this.secureTokenIsQuery = n.secureTokenIsQuery;
        {{/isSecureToken}}
        {{#isSecureApiKey}}
        this.secureApiKeyValue = n.secureApiKeyValue;
        this.secureApiKeyHeaderOrQueryName = n.secureApiKeyHeaderOrQueryName;
        this.secureApiKeyIsQuery = n.secureApiKeyIsQuery;
        {{/isSecureApiKey}}
        {{#isSecureBasic}}
        this.username = n.username;
        this.password = n.password;
        {{/isSecureBasic}}
        {{/isSecure}}
    }

    RED.nodes.registerType('{{&nodeName}}-service', {{&className}}ServiceNode, {
        host: { type: 'text' },
        credentials: {
            {{#isSecure}}
            {{#isSecureToken}}
            secureTokenValue: { type: 'password' },
            {{/isSecureToken}}
            {{#isSecureApiKey}}
            secureApiKeyValue: { type: 'password' },
            {{/isSecureApiKey}}
            {{#isSecureBasic}}
            username: { type: 'text' },
            password: { type: 'password' },
            {{/isSecureBasic}}
            {{/isSecure}}
            temp: { type: 'text' }
        }
    });
    {{/hasServiceParams}}
};
